#+TITLE: ANZ Cloud Native Bootcamp
#+AUTHOR: James Blair
#+EMAIL: james.blair@anz.com
#+DATE: [2020-05-09 Sat]

Welcome to the first ANZ Cloud Native Bootcamp for 2020! 

** TODO Setting the scene
SCHEDULED: <2020-05-13 Wed 14:05>

*** TODO Introductions

Firstly some quick introductions, my name is James Blair. I'm an Automation Lead at ANZ New Zealand based in Wellington. I've been in the tech industry for eight years, most of that working within government at Inland Revenue and joined ANZ a year ago.

To introduce this session, I first want to go back to a particular, nostalgic memory of my childhood which is reading Goosebumps choose your own adventure novels by R.L. Stine. We all remember these right?

[[./images/goosebumps.jpg]]

Ok so rest assured my goal for the session today isn't to scare you! However I am hoping we can go on something like an adventure, as we explore cloud native together, so what I've done is set this workshop up in a choose your own adventure style.

Depending on the choices you make within the adventure we'll focus primarily on either [[https://docker.com][docker]] or [[https://kubernetes.io][kubernetes]].


*** TODO Rules of engagement

Before we begin, for this style of workshop to run smoothly, we need to cover some key messages:

 - *Everyone participates* - At each step of this adventure, we all need to collectively vote on the next step we take. To do that we'll be using the polls feature in zoom. Let's test that now to ensure it works for everyone. Additionally as we progress through our journey there will be opportunities to get hands on.

 - *Asking questions* - The aim of this session is to be as interactive as possible, please don't hold questions to the end, I'm happy to answer questions as we go :) 

 - *Resources* - All materials from this workshop will be publicly available on my gitlab and a link provided in chat at the end of our session.

 - *Technology* - For demonstrations and hands on segments we will always be working as one group. To navigate through our adventure and run code we'll be using a technique called [[https://en.wikipedia.org/wiki/Literate_programming][literate programming]] which for some quick history was formed by Donald E. Knuth in 1984. Essentially what this involves is using a development environment such as ~emacs~ with ~org-mode~ to weave our adventure and choices into the flow of processes and code we work through. Additionally we'll be using a tool called ~tmate~ which will allow us to all pair together and share the same development environment and terminals. I've taken to calling what we'll be doing today /*literate pair programming*/.

   
*** TODO Demonstration of literate programming 

I'm going to change my screen layout now in Zoom so you can see what I call our pairing "left eye" and "right eye" which are just terminals. The left eye runs our ~emacs~ development environment. The right eye is the terminal we will be actually running our commands and code in.

Let's take this opportunity to test connectivity with ~tmate~.  Can you all please:

- Open two new browser windows and arrange them side by side
- Navigate to the left eye [[https://tmate.io/t/x]]
- Navigate to the right eye [[https://tmate.io/t/x]]
- In the right eye type ~echo [your first name]~


*** TODO Questions before we begin

Again before we start our journey, does anyone have any questions or have any issues connecting with ~tmate~?

    
** TODO Starting our adventure
SCHEDULED: <2020-05-13 Wed 14:20>

So here you are, a week into a new Summer of Tech internship at ANZ and you've been assigned to one of our cloud squads. You've been tasked with helping to migrate an internal application into a scalable cloud native service that can be run on a public cloud provider such as Google or AWS.

The application in question is a basic pdf conversion app written in python which is currently running on a virtual machine on premises.

To get underway you [[What cloud native means][start by looking up what "cloud native" means]]


** TODO What cloud native means
SCHEDULED: <2020-05-13 Wed 14:25>

You make a start by looking up what "cloud native" means, finding your way to the [[https://github.com/cncf/toc/blob/master/DEFINITION.md][definition]] approved by the [[https://www.cncf.io/][Cloud Native Computing Foundation]] in 2018:

#+begin_quote
"Cloud native technologies empower organizations to build and run scalable applications in modern, dynamic environments such as public, private, and hybrid clouds. Containers, service meshes, microservices, immutable infrastructure, and declarative APIs exemplify this approach.

These techniques enable loosely coupled systems that are resilient, manageable, and observable. Combined with robust automation, they allow engineers to make high-impact changes frequently and predictably with minimal toil.

The Cloud Native Computing Foundation seeks to drive adoption of this paradigm by fostering and sustaining an ecosystem of open source, vendor-neutral projects. We democratize state-of-the-art patterns to make these innovations accessible for everyone."
#+end_quote

A wordy official definition, so from my perspective, when I'm talking about cloud native computing generally what we're talking about is code that runs in [[https://www.docker.com/][docker]] containers, is orchestrated by [[https://kubernetes.io/][kubernetes]] and runs on a public cloud provider like Google or Amazon Web Services.

Now that you've had a look at what cloud native means you [[Why cloud native is important][take a look at why it's important]].


** TODO Why cloud native is important
SCHEDULED: <2020-05-13 Wed 14:30>

Following some brief research you find it's not enough to just "lift and shift" a business application to simply operate in the cloud. Instead to take advantage of the scalability and elasticity of the cloud the business application needs to be re-architected to ensure that cloud is a core part of the design process.

You know you could really easily spin up a virtual machine in the cloud and manually install python in order to run our application, but you know that would not make the application cloud native. Along the way you find a great meme on that topic:
 
[[./images/dilbert.jpg]]

Memes aside, it's time to make a start on re-architecting our application to be cloud native. You know you could transform the application to be serverless, or run the application on a managed kubernetes cluster, do you:

- [[Going serverless][1 - Decide to go with serverless]]
- [[Going kubernetes][2 - Decide to go with kubernetes]]


** TODO Going serverless
SCHEDULED: <2020-05-13 Wed 14:35>

Serverless architecture is taking off across the globe. You know that it's easy way deploy single functions to any of the major cloud providers.

One of the common misconceptions is that serverless is only for simple code functions, major cloud providers now support running [[https://cloud.google.com/blog/products/application-development/5-principles-for-cloud-native-architecture-what-it-is-and-how-to-master-it][stateless]] containers in a serverless fashion as well.
 
[[./images/serverless.jpg]]
 
Given that the implementations of serverless vary across different cloud providers our next choice is which cloud provider we want to deploy on, do you pick:

- [[Going serverless on Google Cloud Platform][1 - Google Cloud Platform]]
- [[Going serverless on Amazon Web Services][2 - Amazon Web Services]]


** TODO Going kubernetes
SCHEDULED: <2020-05-13 Wed 14:35>

Kubernetes (aka k8s) is the open source container orchestration system that is becoming ubiquitous across the planet, it was original created by Google and released in 2015 alongside the creation of the [[https://cncf.io][Cloud Native Computing Foundation]]. 

You know it can automate the deployment, management and scaling of container based applications so you figure it would be a good option for moving our business application to a cloud native ar chitecture.
 
[[./images/kubernetes.jpg]]
 
Memes aside, it's time to make a start, you know that the first step to running an application on kubernetes is getting your application [[Building a docker container image][built into a docker container image]].


** TODO Going serverless on Google Cloud Platform
SCHEDULED: <2020-05-13 Wed 14:40>

Google have...


** TODO Going serverless on Amazon Web Services

AWS have...


** TODO Building a docker container image
SCHEDULED: <2020-05-13 Wed 14:40>

You make a start on building a docker image for your application. For a quick refresher you take a quick look at some context on what a container is.

#+NAME: Container description
#+begin_quote
"Containers are a way to package software (e.g. web server, proxy, batch process worker) so that you can run your code and all of its dependencies in a resource isolated process. You might be thinking, "Wait, isn't that a virtual machine (VM)?" Containers virtualize the operating system, while VMs virtualize the hardware. Containers provide isolation, portability and repeatability, so your developers can easily spin up an environment and start building without the heavy lifting. More importantly, containers ensure your code runs in the same way anywhere, so if it works on your laptop, it will also work in production."
#+end_quote

Our first step to building a docker container image is creating a [[https://docs.docker.com/engine/reference/builder/][Dockerfile]]. A quick look at the docs explains what a Dockerfile is.

#+NAME: Dockerfile description
#+begin_quote
"Docker can build images automatically by reading the instructions from a Dockerfile. A Dockerfile is a text document that contains all the commands a user could call on the command line to assemble an image. Using docker build users can create an automated build that executes several command-line instructions in succession."
#+end_quote

#+NAME: Clone the current application
#+begin_src tmate
# Clone the existing application
git clone https://gitlab.jamma.life/jmhbnz/cloud-native-bootcamp.git

# Navigate to the cloned folder
cd cloud-native-bootcamp/pdf-app
#+end_src

You can see one of your squad memebers had already started drafting a Dockerfile, however they had been pulled to another project and could not finish it.  Let's take a look at that [[./pdf-app/Dockerfile][Dockerfile]].

Review the contents of the file and you'll see a few comments indicating what still needs to be done. Comments are denoted by a "#".

